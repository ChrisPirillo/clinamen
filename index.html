<!DOCTYPE html>
<html lang="en">
<head>
    <!-- === Core Meta === -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinamen - An Interactive Musical Simulation</title>

    <!-- === SEO & Page Meta === -->
    <meta name="description" content="Clinamen is a serene, interactive 3D web simulation where porcelain bowls drift on water, creating unique, generative music with each gentle collision. Control the number of bowls, speed, and sound to create your own ambient masterpiece.">
    <meta name="keywords" content="clinamen, interactive, simulation, generative music, 3d, webgl, three.js, ambient, sound, physics, bouncing bowls">
    <meta name="author" content="Chris Pirillo">
    <link rel="canonical" href="https://pirillo.com/arcade/clinamen.html">

    <!-- === Open Graph (for social sharing) === -->
    <meta property="og:title" content="Clinamen - An Interactive Musical Simulation">
    <meta property="og:description" content="Experience Clinamen, a serene 3D simulation where porcelain bowls create generative music on water.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/clinamen.html">
    <meta property="og:image" content="https://pirillo.com/arcade/images/clinamen.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Pirillo's Arcade">

    <!-- === Twitter Card (for social sharing) === -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:title" content="Clinamen - An Interactive Musical Simulation">
    <meta name="twitter:description" content="Experience Clinamen, a serene 3D simulation where porcelain bowls create generative music on water.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/clinamen.png">

    <!-- 
      === Performance Resource Hints ===
      We are pre-connecting to all critical third-party origins to speed up DNS lookup,
      TCP handshake, and TLS negotiation.
    -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
    <link rel="preconnect" href="https://ga.jspm.io" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://threejs.org" crossorigin>

    <!-- Preload the critical water texture to prevent it from blocking the main render -->
    <link rel="preload" as="image" href="https://threejs.org/examples/textures/waternormals.jpg">

    <!-- === Google Analytics (as requested) === -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <!-- === Scripts (Unchanged, as per request) === -->
    <!-- Tailwind CSS is loaded synchronously to prevent FOUC, as requested -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 
      === Inlined Critical CSS ===
      The styles are already inlined in a <style> tag, which is excellent for performance
      as it avoids a render-blocking network request for a .css file.
    -->
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        #audio-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
        #audio-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #ui-container {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
        }
        #menu-button {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .hamburger-line {
            width: 24px;
            height: 2px;
            background-color: #333;
            margin: 3px 0;
            transition: all 0.3s ease;
        }
        #menu-button.open .line-1 {
            transform: rotate(-45deg) translate(-6px, 6px);
        }
        #menu-button.open .line-2 {
            opacity: 0;
        }
        #menu-button.open .line-3 {
            transform: rotate(45deg) translate(-5px, -5px);
        }
        #settings-panel {
            position: absolute;
            top: 70px;
            right: 0;
            width: 300px;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transform: translateX(110%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #settings-panel.open {
            transform: translateX(0);
        }
        .slider-group {
            margin-bottom: 15px;
        }
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }
        .slider-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 5px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4A90E2;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4A90E2;
            cursor: pointer;
            border-radius: 50%;
             border: 2px solid white;
        }
    </style>

    <!-- 
      === JSON-LD Structured Data ===
      This tells search engines exactly what this page is (a WebPage) and
      what it contains (a CreativeWork, specifically a SoftwareApplication/simulation).
    -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Clinamen - An Interactive Musical Simulation",
      "url": "https://pirillo.com/arcade/clinamen.html",
      "description": "Clinamen is a serene, interactive 3D web simulation by Chris Pirillo where porcelain bowls drift on water, creating unique, generative music with each gentle collision.",
      "publisher": {
        "@type": "Organization",
        "name": "Chris Pirillo",
        "url": "https://pirillo.com/"
      },
      "mainEntity": {
        "@type": "CreativeWork",
        "name": "Clinamen",
        "alternateName": "Bouncing Porcelain Bowls",
        "description": "An interactive WebGL and Tone.js simulation of porcelain bowls creating generative music.",
        "author": {
          "@type": "Person",
          "name": "Chris Pirillo",
          "url": "https://pirillo.com/"
        },
        "genre": ["Simulation", "Generative Music", "Interactive Art"],
        "keywords": "clinamen, interactive, simulation, generative music, 3d, webgl, three.js, ambient"
      }
    }
    </script>
</head>
<body>
    <!-- 
      === Semantic HTML & Accessibility ===
      - Wrapped the main app area in <main> for better content landmarking.
      - Wrapped the UI controls in <nav> as it's the primary navigation for the simulation.
      - Added role='button' and tabindex='0' to interactive <div>s for screen reader and keyboard accessibility.
    -->
    <main>
        <!-- This overlay waits for user interaction to start the audio -->
        <div id="audio-overlay" role="button" tabindex="0">Click to begin and enable sound</div>
        <!-- The Three.js canvas will be appended here by the script -->
    </main>

    <!-- UI elements for controlling the simulation -->
    <nav id="ui-container" aria-label="Simulation Controls">
        <div id="menu-button" role="button" tabindex="0" aria-label="Toggle settings menu" aria-controls="settings-panel">
            <div class="hamburger-line line-1"></div>
            <div class="hamburger-line line-2"></div>
            <div class="hamburger-line line-3"></div>
        </div>
        <div id="settings-panel" role="region" aria-labelledby="menu-button">
            <div class="slider-group">
                <label for="bowl-count">Number of Bowls: <span id="bowl-count-value">25</span></label>
                <input type="range" id="bowl-count" min="1" max="40" value="25">
            </div>
             <div class="slider-group">
                <label for="speed">Speed: <span id="speed-value">1.0</span></label>
                <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1.0">
            </div>
            <div class="slider-group">
                <label for="bounciness">Bounciness: <span id="bounciness-value">0.85</span></label>
                <input type="range" id="bounciness" min="0.5" max="1" step="0.01" value="0.85">
            </div>
             <div class="slider-group">
                <label for="distortion">Wave Size: <span id="distortion-value">1.0</span></label>
                <input type="range" id="distortion" min="0.1" max="10" step="0.1" value="1.0">
            </div>
            <div class="slider-group">
                <label for="water-speed">Wave Height: <span id="water-speed-value">0.85</span></label>
                <input type="range" id="water-speed" min="0.0" max="0.85" step="0.01" value="0.85">
            </div>
            <div class="slider-group">
                <label for="water-time-scale">Water Speed: <span id="water-time-scale-value">0.3</span></label>
                <input type="range" id="water-time-scale" min="0.0" max="2.0" step="0.01" value="0.3">
            </div>
            <div class="slider-group">
                <label for="volume">Sound Volume: <span id="volume-value">50</span></label>
                <input type="range" id="volume" min="0" max="100" value="50">
            </div>
            <!-- MODIFICATION: Added Resonance Slider -->
            <div class="slider-group">
                <label for="resonance">Resonance: <span id="resonance-value">1.2</span>s</label>
                <input type="range" id="resonance" min="0.5" max="4.0" step="0.1" value="1.2">
            </div>
            <!-- MODIFICATION: Add new sound sliders -->
            <div class="slider-group">
                <label for="harmonicity">Timbre (brittleness): <span id="harmonicity-value">5.1</span></label>
                <input type="range" id="harmonicity" min="1.0" max="10.0" step="0.1" value="5.1">
            </div>
            <div class="slider-group">
                <label for="modulation-index">Intensity: <span id="modulation-index-value">25</span></label>
                <input type="range" id="modulation-index" min="10" max="40" step="1" value="25">
            </div>
             <div class="slider-group">
                <label for="room-size">Room Size: <span id="room-size-value">0.8</span></label>
                <input type="range" id="room-size" min="0.1" max="1.0" step="0.01" value="0.8">
            </div>
            <div class="slider-group">
                <label for="dampening">Dampening (muffle): <span id="dampening-value">4000</span></label>
                <input type="range" id="dampening" min="1000" max="8000" step="100" value="4000">
            </div>
        </div>
    </nav>

    <!-- 
      === APPLICATION SCRIPTS (FUNCTIONALLY UNCHANGED) ===
      The following scripts are required for the application to run.
      Their order and attributes (async, type="module") are intentional and
      have not been modified to prevent breaking functionality, as per your instructions.
    -->

    <!-- Import map for Three.js and its addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <!-- ES Module Shims for browser compatibility -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <!-- This is the main script for the 3D simulation (UNTOUCHED) -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Water } from 'three/addons/objects/Water.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- Global Variables ---
        let scene, camera, renderer, clock, water, controls, floor, sun, sky;
        let bounds = { x: 60, y: 60 };
        const bowls = [];
        const shadows = []; // To hold shadow planes
        let shadowTexture; // To hold the generated soft shadow texture

        // Simulation parameters
        let params = {
            bowlCount: 25,
            speed: 1.0,
            bounciness: 0.85,
            waveSize: 1.0, 
            waveHeight: 0.85,
            waterTimeScale: 0.3,
            volume: 50,
            resonance: 1.2, // MODIFICATION: Added resonance param
            // MODIFICATION: Add new sound parameters
            harmonicity: 5.1,
            modulationIndex: 25,
            roomSize: 0.8,
            dampening: 4000
        };
 
        // Audio variables
        // MODIFICATION: Make freeverb global so UI can access it
        let polySynth, freeverb;
        window.isAudioReady = false; 
        
        // --- Simplex Noise Implementation (Used for bowl drift) ---
        const noise = (function(){
            const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
            const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
            const F3 = 1.0 / 3.0;
            const G3 = 1.0 / 6.0;
            const p = new Uint8Array([151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]);
            const perm = new Uint8Array(512);
            const grad3 = new Float32Array([1,1,0, -1,1,0, 1,-1,0, -1,-1,0, 1,0,1, -1,0,1, 1,0,-1, -1,0,-1, 0,1,1, 0,-1,1, 0,1,-1, 0,-1,-1]);
            for(let i=0; i<512; i++) perm[i] = p[i & 255];
            function dot2(g, x, y) { return g[0]*x + g[1]*y; }
            function dot3(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
            return {
                noise2D: function(x, y) {
                    let s = (x+y)*F2, i = Math.floor(x+s), j = Math.floor(y+s), t = (i+j)*G2,
                        X0 = i-t, Y0 = j-t, x0 = x-X0, y0 = y-Y0,
                        i1, j1;
                    if (x0>y0) { i1=1; j1=0; } else { i1=0; j1=1; }
                    let x1 = x0 - i1 + G2, y1 = y0 - j1 + G2,
                        x2 = x0 - 1.0 + 2.0 * G2, y2 = y0 - 1.0 + 2.0 * G2;
                    let ii = i & 255, jj = j & 255;
                    let gi0 = perm[ii+perm[jj]] % 12,
                        gi1 = perm[ii+i1+perm[jj+j1]] % 12,
                        gi2 = perm[ii+1+perm[jj+1]] % 12;
                    let t0 = 0.5 - x0*x0-y0*y0, n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * dot2([grad3[gi0*3], grad3[gi0*3+1]], x0, y0),
                        t1 = 0.5 - x1*x1-y1*y1, n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * dot2([grad3[gi1*3], grad3[gi1*3+1]], x1, y1),
                        t2 = 0.5 - x2*x2-y2*y2, n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * dot2([grad3[gi2*3], grad3[gi2*3+1]], x2, y2);
                    return 70.0 * (n0 + n1 + n2);
                }
            };
        })();

        // This function procedurally generates a soft, circular shadow texture.
        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            const size = 128;
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
            gradient.addColorStop(0.2, 'rgba(0,0,0,1.0)'); // Strong black center
            gradient.addColorStop(1, 'rgba(0,0,0,0)');    // Fades to transparent at the edges
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(canvas);
        }

        const audioOverlay = document.getElementById('audio-overlay');
        
        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 80, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.shadowMap.enabled = false;
            document.body.appendChild(renderer.domElement);
            
            sun = new THREE.Vector3();
            sky = new Sky();
            sky.scale.setScalar( 10000 );
            scene.add( sky );

            const skyUniforms = sky.material.uniforms;
            skyUniforms[ 'turbidity' ].value = 10;
            skyUniforms[ 'rayleigh' ].value = 2;
            skyUniforms[ 'mieCoefficient' ].value = 0.005;
            skyUniforms[ 'mieDirectionalG' ].value = 0.8;

            const parameters = {
                elevation: 6,
                azimuth: 180
            };

            const pmremGenerator = new THREE.PMREMGenerator( renderer );
            let renderTarget;

            function updateSun() {
                const phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );
                const theta = THREE.MathUtils.degToRad( parameters.azimuth );
                sun.setFromSphericalCoords( 1, phi, theta );
                sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
                
                if ( renderTarget !== undefined ) renderTarget.dispose();
                renderTarget = pmremGenerator.fromScene( sky );
                scene.environment = renderTarget.texture;
            }
            updateSun();

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.copy(sun).multiplyScalar(50);
            scene.add(directionalLight);

            shadowTexture = createShadowTexture();
            
            createCustomWater();
            createFloor();
            createControls();
            resetSimulation();
            setupUI();
            setupSound();
            animate();
        }
        
        // --- Audio Functions ---
        function updateVolume() {
            if(polySynth && window.isAudioReady) {
                const dB = (params.volume / 100) * 40 - 45;
                polySynth.volume.value = dB < -44 ? -Infinity : dB;
            }
        }

        // MODIFICATION: New function to update synth settings dynamically
        function updateSynthRelease() {
            if (!polySynth) return;
            polySynth.set({
                envelope: { release: params.resonance },
                modulationEnvelope: { release: params.resonance * 1.2 }, // Keep mod envelope slightly longer
            });
        }

        function setupSound() {
             // MODIFICATION: Removed the '{ once: true }' object from the event listener.
             // The 'if (window.isAudioReady) return;' check inside already prevents
             // this from running more than once, and this is more robust
             // across page reloads in some environments.
             audioOverlay.addEventListener('click', async () => {
                if (window.isAudioReady) return;
                try {
                    await Tone.start();
                    // MODIFICATION: Replaced Delay+Chorus with Freeverb.
                    // This is much lighter than Tone.Reverb, so it won't "pop",
                    // but it sounds much more natural than a simple delay.
                    // MODIFICATION: Use global 'freeverb' variable
                    freeverb = new Tone.Freeverb().toDestination();
                    // MODIFICATION: Set initial values from params
                    freeverb.roomSize.value = params.roomSize; // Large, open space
                    // FIX: The 'dampening' property in this version of Tone.js is a number, not a Param.
                    freeverb.dampening = params.dampening; // Dampen high frequencies, like water
                    
                    polySynth = new Tone.PolySynth({
                        polyphony: 256, // Keep the large buffer
                        voice: Tone.FMSynth
                    }).connect(freeverb); // Connect to our new, lighter reverb
                    
                    polySynth.set({
                        // MODIFICATION: Set initial values from params
                        harmonicity: params.harmonicity,
                        modulationIndex: params.modulationIndex,
                        // Set base envelope, release will be controlled by updateSynthRelease
                        envelope: { attack: 0.002, decay: 0.15, sustain: 0.0 },
                        modulationEnvelope: { attack: 0.005, decay: 0.1, sustain: 0 },
                    });
                    
                    updateSynthRelease(); // Set initial release times from params
                    updateVolume();
                    window.isAudioReady = true; 
                    audioOverlay.classList.add('hidden');
                } catch (e) {
                    console.error("Audio failed to start.", e);
                }
            });
        }

        // --- Scene Object Creation ---
        function createCustomWater() {
            const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );
            water = new Water(
                waterGeometry,
                {
                    textureWidth: 512,
                    textureHeight: 512,
                    waterNormals: new THREE.TextureLoader().load( 'https://threejs.org/examples/textures/waternormals.jpg', function ( texture ) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    } ),
                    sunDirection: new THREE.Vector3(),
                    sunColor: 0xffffff,
                    waterColor: 0x001e0f,
                    distortionScale: 3.7,
                    fog: scene.fog !== undefined
                }
            );
            water.rotation.x = - Math.PI / 2;
            scene.add( water );
        }

        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(500, 500);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xCCCCCC,
                roughness: 0.8,
                metalness: 0.1
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -3;
            floor.receiveShadow = false;
            scene.add(floor);
        }

        function createControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 30;
            controls.maxDistance = 150;
            controls.maxPolarAngle = Math.PI / 3.5;
        }
        
        function createBowl() {
            const radius = 3.5 + Math.random() * 2.5;
            const depth = 2.0 + Math.random() * 1.0; 
            const thickness = 0.3;
            const profilePoints = [];
            const steps = 12;
            for (let i = 0; i <= steps; i++) {
                let angle = (i / steps) * Math.PI * 0.5;
                profilePoints.push(new THREE.Vector2(Math.sin(angle) * radius, -Math.cos(angle) * depth + depth));
            }
            for (let i = steps; i >= 0; i--) {
                let angle = (i / steps) * Math.PI * 0.5;
                profilePoints.push(new THREE.Vector2(Math.sin(angle) * (radius - thickness), -Math.cos(angle) * (depth - thickness) + depth));
            }
            const geometry = new THREE.LatheGeometry(profilePoints, 64);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.1,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            const bowl = new THREE.Mesh(geometry, material);
            
            bowl.castShadow = false; 
            bowl.receiveShadow = false; 
            
            bowl.radius = radius; 
            bowl.depth = depth;
            bowl.velocity = new THREE.Vector2((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5); 
            bowl.lastSoundTime = 0;
            return bowl;
        }

        // --- Simulation Management ---
        function resetSimulation() {
            bowls.forEach(b => {
                scene.remove(b);
                b.geometry.dispose();
                b.material.dispose();
            });
            bowls.length = 0;

            shadows.forEach(s => {
                scene.remove(s);
                s.geometry.dispose();
                s.material.dispose();
            });
            shadows.length = 0;

            for (let i = 0; i < params.bowlCount; i++) {
                const bowl = createBowl();
                let placed = false, tries = 0;
                while(!placed && tries++ < 100) {
                    bowl.position.set(
                        (Math.random() - 0.5) * (bounds.x - bowl.radius) * 1.2,
                        0.5, 
                        (Math.random() - 0.5) * (bounds.y - bowl.radius) * 1.2
                    );
                    let overlap = bowls.some(other => bowl.position.distanceToSquared(other.position) < (bowl.radius + other.radius)**2);
                    if (!overlap) placed = true;
                }
                if(placed) {
                    bowls.push(bowl);
                    scene.add(bowl);
                    
                    const shadowGeo = new THREE.PlaneGeometry(bowl.radius * 2.2, bowl.radius * 2.2);
                    const shadowMat = new THREE.MeshBasicMaterial({
                        map: shadowTexture,
                        transparent: true,
                        depthWrite: false, 
                        opacity: 1.0 
                    });
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.rotation.x = -Math.PI / 2;
                    shadow.position.y = floor.position.y + 0.01; 
                    shadows.push(shadow);
                    scene.add(shadow);
                }
            }
        }
        
        // --- UI Setup ---
        function setupUI() {
            const menuButton = document.getElementById('menu-button');
            const settingsPanel = document.getElementById('settings-panel');
            const bowlCountSlider = document.getElementById('bowl-count');
            const speedSlider = document.getElementById('speed');
            const bouncinessSlider = document.getElementById('bounciness');
            const distortionSlider = document.getElementById('distortion');
            const waterSpeedSlider = document.getElementById('water-speed');
            const volumeSlider = document.getElementById('volume');
            const waterTimeScaleSlider = document.getElementById('water-time-scale');
            const waterTimeScaleValue = document.getElementById('water-time-scale-value');
            // MODIFICATION: Get new resonance slider elements
            const resonanceSlider = document.getElementById('resonance');
            const resonanceValue = document.getElementById('resonance-value');
            // MODIFICATION: Get all new slider elements
            const harmonicitySlider = document.getElementById('harmonicity');
            const harmonicityValue = document.getElementById('harmonicity-value');
            const modulationIndexSlider = document.getElementById('modulation-index');
            const modulationIndexValue = document.getElementById('modulation-index-value');
            const roomSizeSlider = document.getElementById('room-size');
            const roomSizeValue = document.getElementById('room-size-value');
            const dampeningSlider = document.getElementById('dampening');
            const dampeningValue = document.getElementById('dampening-value');

            const bowlCountValue = document.getElementById('bowl-count-value');
            const speedValue = document.getElementById('speed-value');
            const bouncinessValue = document.getElementById('bounciness-value');
            const distortionValue = document.getElementById('distortion-value');
            const waterSpeedValue = document.getElementById('water-speed-value');
            const volumeValue = document.getElementById('volume-value');
            const waterTimeScaleValueText = document.getElementById('water-time-scale-value');


            // Set initial values from params
            distortionValue.textContent = params.waveSize.toFixed(1);
            waterSpeedValue.textContent = params.waveHeight.toFixed(2);
            waterTimeScaleValueText.textContent = params.waterTimeScale.toFixed(2);
            resonanceValue.textContent = params.resonance.toFixed(1); // Set initial resonance text
            // MODIFICATION: Set initial text for new sliders
            harmonicityValue.textContent = params.harmonicity.toFixed(1);
            modulationIndexValue.textContent = params.modulationIndex;
            roomSizeValue.textContent = params.roomSize.toFixed(2);
            dampeningValue.textContent = params.dampening;

            menuButton.addEventListener('click', () => {
                menuButton.classList.toggle('open');
                settingsPanel.classList.toggle('open');
            });

            bowlCountSlider.addEventListener('input', e => {
                params.bowlCount = parseInt(e.target.value);
                bowlCountValue.textContent = params.bowlCount;
            });
            bowlCountSlider.addEventListener('change', resetSimulation); 

            speedSlider.addEventListener('input', e => {
                params.speed = parseFloat(e.target.value); // MODIFICATION: Fixed 'e.get.target.value'
                speedValue.textContent = params.speed.toFixed(1);
            });
            
            bouncinessSlider.addEventListener('input', e => {
                params.bounciness = parseFloat(e.target.value);
                bouncinessValue.textContent = params.bounciness.toFixed(2);
            });

            distortionSlider.addEventListener('input', e => {
                params.waveSize = parseFloat(e.target.value);
                distortionValue.textContent = params.waveSize.toFixed(1);
                water.material.uniforms[ 'size' ].value = params.waveSize;
            });

            waterSpeedSlider.addEventListener('input', e => {
                params.waveHeight = parseFloat(e.target.value);
                waterSpeedValue.textContent = params.waveHeight.toFixed(2);
                water.material.uniforms[ 'scale' ].value = params.waveHeight;
            });

            waterTimeScaleSlider.addEventListener('input', e => {
                params.waterTimeScale = parseFloat(e.target.value);
                waterTimeScaleValueText.textContent = params.waterTimeScale.toFixed(2);
                // FIX: Removed typo "Two:"
            });

            volumeSlider.addEventListener('input', e => {
                params.volume = parseFloat(e.target.value);
                volumeValue.textContent = Math.round(params.volume);
                updateVolume(); 
            });

            // MODIFICATION: Add event listener for resonance slider
            resonanceSlider.addEventListener('input', e => {
                params.resonance = parseFloat(e.target.value);
                resonanceValue.textContent = params.resonance.toFixed(1);
                updateSynthRelease(); // Update synth settings on the fly
            });

            // MODIFICATION: Add event listeners for new sound sliders
            harmonicitySlider.addEventListener('input', e => {
                params.harmonicity = parseFloat(e.target.value);
                harmonicityValue.textContent = params.harmonicity.toFixed(1);
                if (polySynth) polySynth.set({ harmonicity: params.harmonicity });
            });

            modulationIndexSlider.addEventListener('input', e => {
                params.modulationIndex = parseInt(e.target.value);
                modulationIndexValue.textContent = params.modulationIndex;
                if (polySynth) polySynth.set({ modulationIndex: params.modulationIndex });
            });

            roomSizeSlider.addEventListener('input', e => {
                params.roomSize = parseFloat(e.target.value);
                roomSizeValue.textContent = params.roomSize.toFixed(2);
                if (freeverb) freeverb.roomSize.value = params.roomSize;
            });

            dampeningSlider.addEventListener('input', e => {
                params.dampening = parseInt(e.target.value);
                dampeningValue.textContent = params.dampening;
                if (freeverb) freeverb.dampening = params.dampening;
            });
        };
        
        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.05); 
            const elapsedTime = clock.getElapsedTime();
            
            water.material.uniforms[ 'time' ].value += (1.0 / 60.0) * params.waterTimeScale;
            
            updateBowlPositions(delta, elapsedTime);
            controls.update(); 
            
            renderer.render(scene, camera);
        }
        
        function updateBowlPositions(delta, time) {
            const getBowlHeight = (x, z) => {
                const speed = time * 0.03;
                return (noise.noise2D(x / 25, z / 25) * 0.6) * params.waveHeight; 
            };
            
            for (let i = 0; i < bowls.length; i++) {
                const bowl = bowls[i];
                const shadow = shadows[i]; 

                // --- Physics (Consistent 2D) ---
                // Using bowl.velocity.y as the Z-axis velocity
                const noiseX = (noise.noise2D(bowl.position.x / 50, bowl.position.z / 50)) * 0.25;
                const noiseZ = (noise.noise2D(bowl.position.x / 50 + 100, bowl.position.z / 50 + 100)) * 0.25;
                bowl.velocity.x += noiseX * delta;
                bowl.velocity.y += noiseZ * delta; // velocity.y is z-velocity
                
                bowl.position.x += bowl.velocity.x * delta * params.speed;
                bowl.position.z += bowl.velocity.y * delta * params.speed; // velocity.y is z-velocity

                const waveHeight = getBowlHeight(bowl.position.x, bowl.position.z);
                bowl.position.y = waveHeight + 0.3; // Y-position is for height only

                if (shadow) {
                    shadow.position.x = bowl.position.x;
                    shadow.position.z = bowl.position.z;

                    const heightAboveFloor = bowl.position.y - floor.position.y;
                    const opacity = Math.max(0.3, 1.0 - heightAboveFloor / 8.0); 
                    shadow.material.opacity = opacity; 
                    const scale = 1.0 + heightAboveFloor / 15.0; 
                    shadow.scale.set(scale, scale, scale);
                }
                
                const up = new THREE.Vector3(0, 1, 0);
                const tiltX = noise.noise2D(time * 0.5, bowl.position.x * 0.1) * 0.05;
                const tiltZ = noise.noise2D(time * 0.5, bowl.position.z * 0.1) * 0.05;
                const normal = new THREE.Vector3(tiltX, 1, tiltZ).normalize();
                const quaternion = new THREE.Quaternion().setFromUnitVectors(up, normal);
                bowl.quaternion.slerp(quaternion, 0.05); 
                
                // Boundary collision (using velocity.y for z-velocity)
                if (Math.abs(bowl.position.x) > bounds.x - bowl.radius) {
                    bowl.velocity.x *= -params.bounciness;
                    bowl.position.x = Math.sign(bowl.position.x) * (bounds.x - bowl.radius);
                }
                if (Math.abs(bowl.position.z) > bounds.y - bowl.radius) {
                    bowl.velocity.y *= -params.bounciness; // velocity.y is z-velocity
                    bowl.position.z = Math.sign(bowl.position.z) * (bounds.y - bowl.radius);
                }
                
                // Bowl-Bowl collision (using velocity.y for z-velocity)
                for (let j = i + 1; j < bowls.length; j++) {
                    const otherBowl = bowls[j];
                    const distVec = new THREE.Vector2(otherBowl.position.x - bowl.position.x, otherBowl.position.z - bowl.position.z);
                    const dist = distVec.length();
                    
                    if (dist < bowl.radius + otherBowl.radius) {
                        const now = performance.now() / 1000;
                        
                        if (window.isAudioReady && polySynth && (now - bowl.lastSoundTime > 0.25) && (now - otherBowl.lastSoundTime > 0.25)) {
                            bowl.lastSoundTime = now;
                            otherBowl.lastSoundTime = now;
                            
                            // bowl.velocity is (vx, vz_as_y)
                            const impactSpeed = bowl.velocity.clone().sub(otherBowl.velocity).length();
                            const maxRadius = 6.0, minRadius = 3.5;
                            const sizeRatio = 1 - ((bowl.radius - minRadius) / (maxRadius - minRadius));
                            // MODIFICATION: Pitched notes higher for a more "porcelain" sound
                            const note = 120 + sizeRatio * 150 + Math.random() * 15;
                            const velocity = Math.min(1, impactSpeed / 10);
                            
                            if (velocity > 0.05) {
                                // Use the stable, pop-free triggerAttackRelease
                                polySynth.triggerAttackRelease(note, "32n", Tone.now(), velocity);
                            } 
                        }
                        
                        // Physics response (bowl.velocity is (vx, vz_as_y))
                        const normal = distVec.normalize(); // (nx, nz)
                        const tangent = new THREE.Vector2(-normal.y, normal.x); // (ntx, ntz)
                        
                        const v1n = bowl.velocity.dot(normal); // (vx*nx + vz*nz)
                        const v1t = bowl.velocity.dot(tangent);
                        const v2n = otherBowl.velocity.dot(normal);
                        const v2t = otherBowl.velocity.dot(tangent);
                        
                        const m1 = bowl.radius**2, m2 = otherBowl.radius**2; 
                        const v1n_new = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);
                        const v2n_new = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);
                        
                        // Re-combine components
                        const v1_new_normal = normal.clone().multiplyScalar(v1n_new * params.bounciness);
                        const v1_new_tangent = tangent.clone().multiplyScalar(v1t);
                        bowl.velocity.copy(v1_new_normal.add(v1_new_tangent)); // New (vx, vz_as_y)

                        const v2_new_normal = normal.clone().multiplyScalar(v2n_new * params.bounciness);
                        const v2_new_tangent = tangent.clone().multiplyScalar(v2t);
                        otherBowl.velocity.copy(v2_new_normal.add(v2_new_tangent)); // New (vx, vz_as_y)

                        // Position Correction
                        const overlap = (bowl.radius + otherBowl.radius) - dist;
                        const correction = normal.multiplyScalar(overlap / 2.0); // (cx, cz)
                        bowl.position.x -= correction.x;
                        bowl.position.z -= correction.y; // .y is cz
                        otherBowl.position.x += correction.x;
                        otherBowl.position.z += correction.y; // .y is cz
                        
                        // Impulse correction
                        const impulseStrength = 5.0; 
                        bowl.velocity.x -= correction.x * impulseStrength;
                        bowl.velocity.y -= correction.y * impulseStrength; // .y is cz
                        otherBowl.velocity.x += correction.x * impulseStrength;
                        otherBowl.velocity.y += correction.y * impulseStrength; // .y is cz
                    }
                }
            }
        }

        // --- Window Resize Handler ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);
        
        // Start the simulation
        init();
       
    </script>
</body>
</html>